#include <fcntl.h>
#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <time.h>
#include <string.h>
#include <sys/types.h>
#include <sys/mman.h>

#include <eeSeqEng.h>

/*************************************
 * now all the subroutines
 *************************************/

eeSeqEng_t* eeseq_new(void) {
  eeSeqEng_t  *self;
  
  self = (eeSeqEng_t*) malloc(sizeof(eeSeqEng_t));
  memset(self, 0, sizeof(eeSeqEng_t));

  self->mode = STREAM1;
  self->max_lines = -1;
  self->debug = 0;
  self->startclock = clock();

  return self;  
}

void eeseq_init(eeSeqEng_t *self, char* infile) {
  self->file_path = infile;
  eeseq_read_experiments(self);
}

void eeseq_read_experiments(eeSeqEng_t *self) {
  int        readCount;
  char       *bufptr2;

  if(self->gzfp == NULL) { self->gzfp = gzopen(self->file_path, "rb"); }

  if(self->buffer == NULL) {
    self->buffer = (char*)malloc(BUFSIZE);
    self->readbuf = (char*)malloc(READ_BUF_SIZE);  
  }
  memset(self->buffer, 0, BUFSIZE);
  
  readCount = gzread(self->gzfp, self->readbuf, READ_BUF_SIZE);
  strncat(self->buffer, self->readbuf, readCount);
  //printf("new buffer length : %d\n", strlen(buffer));
  bufptr2 = self->buffer;
  self->bufptr = self->buffer;
  self->bufend = self->buffer + strlen(self->buffer); /* points at the \0 added by strncat()*/

  while((bufptr2 < self->bufend) && (*bufptr2 != '\0') && (*bufptr2 != '\n')) { bufptr2++; }

  if(*bufptr2 == '\n') {
    *bufptr2 = '\0';
    if(*(self->bufptr)=='#') {
      eeseq_parse_exp_line(self, self->bufptr);
    }
  }
  
  //now reset to the end of the experiment line
  self->seek_pos = (bufptr2+1 - self->buffer);
  self->bufptr = bufptr2+1;
  self->next_obj_id = 0;
}


/**
 * read the 'expression' file generated by the tag extraction process
 ***/
void eeseq_build_index(eeSeqEng_t *self) {
  int        readCount;
  FILE       *fp_idx = NULL;
  long long  byteCount=0, bufferCount=0, seek_pos;
  double     runtime;
  double     mbytes;
  char       *bufptr, *bufptr2, *bufend;
  int        linecount = 0;
  int        tagcount=0;
  int        detectable_tags=0, detect_express=0;
  int        col;
  char       outpath[1024];

  //makes sure everthing is initialized correctly
  gzrewind(self->gzfp);
  memset(self->buffer, 0, BUFSIZE);

  sprintf(outpath, "%s.eeidx", self->file_path);
  fp_idx = fopen(outpath, "w");
  
  printf("long : %ud bytes\n", sizeof(bufferCount));
  while(!gzeof(self->gzfp)) {
    readCount = gzread(self->gzfp, self->readbuf, READ_BUF_SIZE);
    bufferCount++;
    strncat(self->buffer, self->readbuf, readCount);
    //printf("new buffer length : %d\n", (int)strlen(self->buffer));
    bufptr = self->buffer;
    bufptr2 = self->buffer;
    bufend = self->buffer + strlen(self->buffer); /* points at the \0 added by strncat()*/

    while(bufptr2 < bufend) {
      while((bufptr2 < bufend) && (*bufptr2 != '\0') && (*bufptr2 != '\n')) { bufptr2++; }
      if(*bufptr2 == '\n') {
        *bufptr2 = '\0';
        seek_pos = byteCount + (bufptr - self->buffer);
        //fprintf(fp_out, "%s\n", bufptr);

        //fprintf(fp_out, "%s\n", bufptr);
        if((*bufptr!='#')&&(*bufptr!='>')) {
          fwrite(&seek_pos, sizeof(seek_pos), 1, fp_idx);
          //printf("OBJECT %7d : %10lld offset :: %s \n", linecount, seek_pos, bufptr);
          linecount++;
        }

        bufptr2 = bufptr2+1;
        bufptr = bufptr2;
        
      }
    } //bottom of the while(bufptr2<bufend){} loop

    //update the bytecount since we are done with this buffer
    //printf("end of buffer\nstarting byteCount:%lld, readCount:%d, bufend:%d,  bufptr:%d\n", byteCount, readCount, (bufend-buffer), (bufptr-buffer));
    byteCount = byteCount + (bufptr - self->buffer);
    if(bufferCount % 1000 == 0) {
      printf("  read %1.3f Mbytes\t%d lines\n", ((double)(byteCount))/(1024.0*1024.0), linecount);
    }

    /* not an end of line means we ran off the buffer
       so we need to shift the rest of the buffer
       to the beginning and break out to read more
       of the file */
    strcpy(self->buffer, bufptr); //the end over, very efficient


  } //end of the while(!gzeof(gzfp)){} loop
  gzrewind(self->gzfp);
  fclose(fp_idx);

  printf("\n%lld total expression\n", self->total_expression);
  for(col=0; col<self->exp_count; col++) {
    printf("experiment[%3d] %15s :: total_express %lld\n", col, self->experiments[col].full_name, self->experiments[col].total_express);
  }
  printf("\n");
  
  mbytes = ((double)(byteCount))/(1024.0*1024.0);
  runtime = (double)(clock() - self->startclock) / CLOCKS_PER_SEC;
  printf("just read %d lines\n", linecount);
  printf("tag count: %d\n", tagcount);
  printf("detectable tags: %d [%d] (%1.1f %%)\n", detectable_tags, detect_express, (detect_express *100.0 / self->total_expression));
  printf("just read %1.3f Mbytes\n", mbytes);
  printf("  %1.3f secs\n", (float)runtime);
  printf("  %1.3f kilolines/sec\n", linecount/runtime/1000.0); 
  printf("  %1.3f mbytes/sec\n", mbytes/runtime); 
}


/**
 * read the 'expression' file generated by the tag extraction process
 ***/
seqtag_t* eeseq_nexttag(eeSeqEng_t *self) {
  int        readCount;
  char       *bufptr2;
  seqtag_t   *tag = NULL;

  bufptr2 = self->bufptr;
  do {
    while(bufptr2 < self->bufend) {
      while((bufptr2 < self->bufend) && (*bufptr2 != '\0') && (*bufptr2 != '\n')) { bufptr2++; }
      if(*bufptr2 == '\n') {
        *bufptr2 = '\0';
        //fprintf(fp_out, "%s\n", bufptr);

        //
        // do things with the line buffer here
        //
        //printf("LINE %7lld : %10lld offset :: %s \n", self->next_obj_id, self->seek_pos, self->bufptr);
        tag = eeseq_parse_tag_line(self, self->bufptr, self->next_obj_id);
        self->seek_pos = self->seek_pos + (bufptr2 - self->bufptr) + 1;
        self->bufptr = bufptr2+1;
        bufptr2 = bufptr2+1;

        if(tag) { 
          //if(self->debug) { eeseq_print_tag(self, tag); }
          self->next_obj_id++;
          return tag;
        }
      }
    } //bottom of the while(bufptr2<bufend){} loop
    
    /* we ran off the self->buffer
       so we need to shift the rest of the buffer
       to the beginning and then read more
       of the file */
    strcpy(self->buffer, self->bufptr); //the end over with \0 char, very efficient

    readCount = gzread(self->gzfp, self->readbuf, READ_BUF_SIZE);
    if(readCount<=0) { return NULL; }
    
    strncat(self->buffer, self->readbuf, readCount);
    //printf("new buffer length : %d\n", (int)strlen(self->buffer));
    self->bufptr = self->buffer;
    bufptr2 = self->bufptr;    
    self->bufend = self->buffer + strlen(self->buffer); /* points at the \0 added by strncat()*/
  } while(!gzeof(self->gzfp));
  return NULL;
}


/**
 * read the 'expression' file generated by the tag extraction process
 ***/
void eeseq_readtags(eeSeqEng_t *self) {
  int        readCount;
  FILE       *fp_out;
  FILE       *fp_idx = NULL;
  long long  byteCount=0, bufferCount=0, seek_pos;
  char       *buffer, *readbuf;
  int        bufsize = 1024*1024;
  double     runtime;
  double     mbytes;
  char       *bufptr, *bufptr2, *bufend;
  int        linecount = 0;
  int        tagcount=0;
  int        detectable_tags=0, detect_express=0;
  int        col;
  char       outpath[1024];
  seqtag_t   *tag;

  if(self->gzfp == NULL) { self->gzfp = gzopen(self->file_path, "rb"); }

  if(self->mode == INDEX) {
    sprintf(outpath, "%s.eeidx", self->file_path);
    fp_idx = fopen(outpath, "w");
  }
  
  sprintf(outpath, "%s.copy", self->file_path);
  fp_out = fopen(outpath, "w");
  
  printf("long : %ud bytes\n", sizeof(bufferCount));
  buffer = (char*)malloc(bufsize);
  memset(buffer, 0, bufsize);
  readbuf = (char*)malloc(READ_BUF_SIZE);  
    
  if(self->mode == ACCESS) {
    gzseek(self->gzfp, (z_off_t)self->access_id, SEEK_SET);
  }

  while(!gzeof(self->gzfp)) {
    readCount = gzread(self->gzfp, readbuf, READ_BUF_SIZE);
    bufferCount++;
    strncat(buffer, readbuf, readCount);
    //printf("new buffer length : %d\n", (int)strlen(buffer));
    bufptr = buffer;
    bufptr2 = buffer;
    bufend = buffer + strlen(buffer); /* points at the \0 added by strncat()*/

    while(bufptr2 < bufend) {
      while((bufptr2 < bufend) && (*bufptr2 != '\0') && (*bufptr2 != '\n')) { bufptr2++; }
      if(*bufptr2 == '\n') {
        *bufptr2 = '\0';
        seek_pos = byteCount + (bufptr - buffer);
        //printf("LINE %7d : %10lld offset :: %s \n", linecount, seek_pos, bufptr);
        //fprintf(fp_out, "%s\n", bufptr);

        //
        // do things with the line buffer here
        //
        switch (self->mode) {
          case STREAM1:
            tag = eeseq_parse_tag_line(self, bufptr, linecount);
            if(tag) { 
              tagcount++; 
              if(self->debug) { eeseq_print_tag(self, tag); }
              if(tag->total_express > 7) {
                detectable_tags++; 
                detect_express += tag->total_express;
                eeseq_write_exptag(fp_out, tag);
              }
            }
            eeseq_unlink_tag(tag);
            break;
            
          case INDEX:
            //fprintf(fp_out, "%s\n", bufptr);
            if((*bufptr!='#')&&(*bufptr!='>')) {
              fwrite(&seek_pos, sizeof(seek_pos), 1, fp_idx);
            }
            break;
          
          case ACCESS:
            tag = eeseq_parse_tag_line(self, bufptr, linecount);
            eeseq_print_tag(self, tag);
            eeseq_unlink_tag(tag);
            //problem leave this open to stream from this point forward, but ok for now
            //gzclose(gzfp);
            return;
            break;

          default:
            break;
        }

        linecount++;
        bufptr2 = bufptr2+1;
        bufptr = bufptr2;
        
      }
    } //bottom of the while(bufptr2<bufend){} loop

    //update the bytecount since we are done with this buffer
    //printf("end of buffer\nstarting byteCount:%lld, readCount:%d, bufend:%d,  bufptr:%d\n", byteCount, readCount, (bufend-buffer), (bufptr-buffer));
    byteCount = byteCount + (bufptr - buffer);
    if(bufferCount % 1000 == 0) {
      printf("  read %1.3f Mbytes\t%d lines\n", ((double)(byteCount))/(1024.0*1024.0), linecount);
    }

    /* not an end of line means we ran off the buffer
       so we need to shift the rest of the buffer
       to the beginning and break out to read more
       of the file */
    strcpy(buffer, bufptr); //the end over, very efficient


  } //end of the while(!gzeof(gzfp)){} loop
  gzclose(self->gzfp);
  fclose(fp_out);
  if(self->mode == INDEX) { fclose(fp_idx); }

  printf("\n%lld total expression\n", self->total_expression);
  for(col=0; col<self->exp_count; col++) {
    printf("experiment[%3d] %15s :: total_express %lld\n", col, self->experiments[col].full_name, self->experiments[col].total_express);
  }
  printf("\n");
  
  mbytes = ((double)(byteCount))/(1024.0*1024.0);
  runtime = (double)(clock() - self->startclock) / CLOCKS_PER_SEC;
  printf("just read %d lines\n", linecount);
  printf("tag count: %d\n", tagcount);
  printf("detectable tags: %d [%d] (%1.1f %%)\n", detectable_tags, detect_express, (detect_express *100.0 / self->total_expression));
  printf("just read %1.3f Mbytes\n", mbytes);
  printf("  %1.3f secs\n", (float)runtime);
  printf("  %1.3f kilolines/sec\n", linecount/runtime/1000.0); 
  printf("  %1.3f mbytes/sec\n", mbytes/runtime); 
}


void eeseq_mmap_idx(eeSeqEng_t *self) {
  off_t      idx_len;
  char       outpath[1024];
  void       *mmap_addr;
  
  if(self->data_fildes == 0) { 
    self->data_fildes = open(self->file_path, O_RDONLY, 0x755); 
  }
  if(self->idx_fildes == 0) {
    sprintf(outpath, "%s.eeidx", self->file_path);
    self->idx_fildes = open(outpath, O_RDONLY, 0x755);
  }
  idx_len = lseek(self->idx_fildes, 0, SEEK_END);  
  if(self->debug) { printf("index file %lld bytes long\n", (long long)idx_len); }
  lseek(self->idx_fildes, 0, SEEK_SET);
  
  mmap_addr =  mmap(NULL, idx_len, PROT_READ, MAP_FILE, self->idx_fildes, 0);
  self->idx_mmap = mmap_addr;
  self->max_id = (idx_len / sizeof(long long)) - 1;
  if(self->debug) { printf("index file max ID: %lld\n", (long long)self->max_id); }
}


seqtag_t* eeseq_access_tag(eeSeqEng_t *self, long long id) {
  ssize_t    readCount;
  long long  seek_pos;
  char       *bufptr, *bufptr2, *bufend;
  seqtag_t   *tag = NULL;

  if(self->idx_fildes == 0) { eeseq_mmap_idx(self); }
  
  //
  // ok now the seek magick, got to love memory-mapped binary files
  //  
  seek_pos = self->idx_mmap[id];
  if(self->debug>1) { printf("OBJECT %7lld : %10lld offset\n", id, seek_pos); }
  //gzseek(self->gzfp, seek_pos, SEEK_SET);
  lseek(self->data_fildes, seek_pos, SEEK_SET);

  //
  // and now read the tag
  //
  
  //readCount = gzread(self->gzfp, self->readbuf, 2048);
  readCount = read(self->data_fildes, self->readbuf, 2048);
  self->buffer[0] = '\0';
  strncat(self->buffer, self->readbuf, readCount);
  
  //printf("new buffer length : %d\n", strlen(buffer));
  bufptr = self->buffer;
  bufptr2 = self->buffer;
  bufend = self->buffer + strlen(self->buffer); /* points at the \0 added by strncat()*/

  while((bufptr2 < bufend) && (*bufptr2 != '\0') && (*bufptr2 != '\n')) { bufptr2++; }

  if(*bufptr2 == '\n') {
    *bufptr2 = '\0';
    if(self->debug>1) { printf("LINE %7lld : %10lld offset :: %s \n", id, seek_pos, bufptr); }
    tag = eeseq_parse_tag_line(self, bufptr, id);
    tag->offset = seek_pos;
  }
  return tag;
}


/*************************************/

seqtag_t*  eeseq_parse_tag_line(eeSeqEng_t* self, char* line, int linenum) {
  seqtag_t  *tag;
  char      *ptr = line;
  char      *str;
  int       col=0;
  int       express=0;

  if(*line =='#') { return NULL; }
  if(*line =='>') { return NULL; }

  tag = (seqtag_t*)malloc(sizeof(seqtag_t));
  memset(tag, 0, sizeof(tag));
  tag->id = linenum;
  tag->exp_count = self->exp_count;

  //printf("LINE : %s\n", line);
  while((ptr = strsep(&line, " \t")) != NULL) {
    if(*ptr== '\0') { break; }
    if(*ptr== '\n') { break; }
    col++;
    //printf("    %d : '%s'\n", col, ptr);
    if(col==1) {
      tag->length = strlen(ptr);
      str =(char*)malloc(tag->length+1);
      strcpy(str, ptr);
      tag->seq = str;
    } else {
      express = strtol(ptr, NULL, 10); 
      if((col-2)< self->exp_count) {
        tag->express[col-2] = express;
        self->experiments[col-2].total_express += express;
      } 
    }
  }
  tag->total_express = express;
  self->total_expression += express;
  //print_tag(self, tag);
  return tag;
}


void eeseq_unlink_tag(seqtag_t *tag) {
  void   *seq;

  if(tag==NULL) { return; }
  seqtag_t *prev, *next;
  prev = tag->prev_tag;
  next = tag->next_tag;
  if(prev != NULL) { prev->next_tag = next; }
  if(next != NULL) { next->prev_tag = prev; }
  seq = tag->seq;
  tag->seq = NULL;
  free(seq);
  free(tag);
}


void eeseq_print_tag(eeSeqEng_t* self, seqtag_t *tag) {
  int col;

  if(tag == NULL) { return; }
  printf("TAG(%ld) [off:%lld len:%d total:%d] %s [", tag->id, tag->offset, tag->length, tag->total_express, tag->seq);
  for(col=0; col<self->exp_count; col++) {
    printf("(%s : %d) ", self->experiments[col].full_name, tag->express[col]);
  }
  printf("]\n");
}


void eeseq_write_exptag(FILE *fp, seqtag_t *tag) {
  int col;

  if(tag == NULL) { return; }
  fprintf(fp, "%s", tag->seq);
  for(col=0; col<tag->exp_count; col++) {
    fprintf(fp, "\t%d", tag->express[col]);
  }
  fprintf(fp, "\t%d\n", tag->total_express);
}


/*************************************/

void eeseq_parse_exp_line(eeSeqEng_t* self, char* line) {
  char      *ptr = line;
  char      *str;
  int       col=0;

  //printf("LINE : %s\n", line);
  while((ptr = strsep(&line, "\t")) != NULL) {
    if(*ptr== '\0') { break; }
    if(*ptr== '\n') { break; }
    col++;
    //printf("    %d : '%s'\n", col, ptr);
    if(col>1) {
      str =(char*)malloc(strlen(ptr)+1);
      strcpy(str, ptr);
      self->experiments[col-2].full_name = str;
      self->experiments[col-2].total_express = 0;
    }
  }
  self->exp_count = col-2;
  if(self->debug) {
    for(col=0; col<self->exp_count; col++) {
      printf("experiment[%d] = '%s'\n", col, self->experiments[col].full_name);
    }
  }
}

