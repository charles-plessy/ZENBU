# $Id: ExpressionDatatype.pm,v 1.4 2010/04/20 05:45:30 severin Exp $
=head1 NAME - EEDB::ExpressionDatatype

=head1 SYNOPSIS

=head1 DESCRIPTION

=head1 CONTACT

Jessica Severin <severin@gsc.riken.jp>

=head1 LICENSE

 * Software License Agreement (BSD License)
 * EdgeExpressDB [eeDB] system
 * copyright (c) 2007-2009 Jessica Severin RIKEN OSC
 * All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Jessica Severin RIKEN OSC nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS ''AS IS'' AND ANY
 * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

=head1 APPENDIX

The rest of the documentation details each of the object methods. Internal methods are usually preceded with a _

=cut

$VERSION = 0.953;

package EEDB::ExpressionDatatype;

use strict;
use Time::HiRes qw(time gettimeofday tv_interval);

use MQdb::MappedQuery;
our @ISA = qw(MQdb::MappedQuery);

#################################################
# Class methods
#################################################

sub class { return "ExpressionDatatype"; }


#################################################
# Instance methods
#################################################

sub init {
  my $self = shift;
  my @args = @_;
  $self->SUPER::init(@args); 
  if(@args and (scalar(@args)==1)) {
    $self->datatype($args[0]);
  }    
  return $self;
}

sub global_uncache {
  my $self = shift;
  return undef;
}

##########################
#
# getter/setter methods of data which is stored in database
#
##########################

sub db_id {
  #datatype is more like a predicate namespace, so the datatype is the universal id
  my $self = shift;
  return "eedb:expression_datatype::" . $self->datatype;
}


sub datatype {
  my $self = shift;
  return $self->{'_datatype'} = shift if(@_);
  $self->{'_datatype'}='' unless(defined($self->{'_datatype'}));
  return $self->{'_datatype'};
}

sub is_active {
  my $self = shift;
  return "y";
}

####################################

sub display_desc
{
  my $self = shift;
  my $str = sprintf("ExpressionDatatype(%s) [%s]", $self->id, $self->datatype);
  return $str;
}

sub display_contents {
  my $self = shift;
  my $str = $self->display_desc;
  return $str;
}

####################################

sub xml_start {
  my $self = shift;
  my $str = sprintf("<datatype type=\"%s\" >", $self->datatype);
  return $str;
}

sub xml_end {
  my $self = shift;
  return "</datatype>\n"; 
}

sub xml {
  my $self = shift;
  
  my $str = $self->xml_start;
  $str .= $self->xml_end;
  return $str;
}

sub new_from_xmltree {
  my $class = shift;
  my $xmlTree = shift;  #a hash tree generated by XML::TreePP
  
  my $self = new $class;
  $self->datatype($xmlTree->{'-type'}) if(defined($xmlTree->{'-type'}));
  return $self;
}


#################################################
#
# DBObject override methods
#
#################################################

sub mapRow {
  my $self = shift;
  my $rowHash = shift;

  $self->primary_id($rowHash->{'datatype_id'});
  $self->datatype($rowHash->{'datatype'});
  return $self;
}

##### storage/update #####

sub fetch_by_id {
  my $class = shift;
  my $db = shift;
  my $id = shift;

  my $sql = "SELECT * FROM expression_datatype WHERE id=?";
  return $class->fetch_single($db, $sql, $id);
}

sub fetch_all {
  my $class = shift;
  my $db = shift;

  my $sql = "SELECT * FROM expression_datatype";
  return $class->fetch_multiple($db, $sql);
}

1;

